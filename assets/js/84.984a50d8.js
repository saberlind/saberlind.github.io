(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{602:function(_,v,t){"use strict";t.r(v);var a=t(4),l=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_11-死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-死锁"}},[_._v("#")]),_._v(" 11.死锁")]),_._v(" "),t("p",[_._v("w：单个进程所需的资源数")]),_._v(" "),t("p",[_._v("n：总资源数")]),_._v(" "),t("p",[_._v("m：进程数")]),_._v(" "),t("p",[_._v("(w-1) * m + 1 <= n")]),_._v(" "),t("p",[_._v("算出来的 w 是最小的不会发生死锁的数")]),_._v(" "),t("h2",{attrs:{id:"_12-网络安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-网络安全"}},[_._v("#")]),_._v(" 12.网络安全")]),_._v(" "),t("h3",{attrs:{id:"被动攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#被动攻击"}},[_._v("#")]),_._v(" 被动攻击")]),_._v(" "),t("blockquote",[t("p",[_._v("包括信息内容泄露和业务流分析")])]),_._v(" "),t("ul",[t("li",[_._v("窃听")]),_._v(" "),t("li",[_._v("电磁或射频截获")]),_._v(" "),t("li",[_._v("业务流分析")])]),_._v(" "),t("h3",{attrs:{id:"主动攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主动攻击"}},[_._v("#")]),_._v(" 主动攻击")]),_._v(" "),t("ul",[t("li",[_._v("截获或修改")]),_._v(" "),t("li",[_._v("重放")]),_._v(" "),t("li",[_._v("伪装")]),_._v(" "),t("li",[_._v("非法使用")]),_._v(" "),t("li",[_._v("服务拒绝")]),_._v(" "),t("li",[_._v("特洛伊木马")]),_._v(" "),t("li",[_._v("陷门")])]),_._v(" "),t("h2",{attrs:{id:"_13-网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-网络"}},[_._v("#")]),_._v(" 13.网络")]),_._v(" "),t("h3",{attrs:{id:"协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[_._v("#")]),_._v(" 协议")]),_._v(" "),t("ul",[t("li",[_._v("IEEE 802\n"),t("ul",[t("li",[_._v("IEEE 802.1：协议概论")]),_._v(" "),t("li",[_._v("IEEE 802.3：局域网协议")]),_._v(" "),t("li",[_._v("IEEE 802.6：城域网协议")]),_._v(" "),t("li",[_._v("IEEE 802.11：无线局域网协议")])])])]),_._v(" "),t("h3",{attrs:{id:"ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip"}},[_._v("#")]),_._v(" IP")]),_._v(" "),t("blockquote",[t("p",[_._v("169.254.0.0 ~ 169.254.255.255")])]),_._v(" "),t("h3",{attrs:{id:"端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#端口"}},[_._v("#")]),_._v(" 端口")]),_._v(" "),t("ul",[t("li",[_._v("FTP\n"),t("ul",[t("li",[_._v("TCP的20：数据")]),_._v(" "),t("li",[_._v("TCP的21：控制")])])]),_._v(" "),t("li",[_._v("SMTP（发信服务器）\n"),t("ul",[t("li",[_._v("TCP的25")])])]),_._v(" "),t("li",[_._v("Telnet\n"),t("ul",[t("li",[_._v("23")])])]),_._v(" "),t("li",[_._v("POP3（收信服务器）\n"),t("ul",[t("li",[_._v("TCP的110")])])]),_._v(" "),t("li",[_._v("HTTP\n"),t("ul",[t("li",[_._v("TCP的80")])])]),_._v(" "),t("li",[_._v("DHCP\n"),t("ul",[t("li",[_._v("UDP的67")])])]),_._v(" "),t("li",[_._v("SNMP\n"),t("ul",[t("li",[_._v("UDP的161")])])]),_._v(" "),t("li",[_._v("DNS\n"),t("ul",[t("li",[_._v("UDP的53")])])])]),_._v(" "),t("h3",{attrs:{id:"服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务"}},[_._v("#")]),_._v(" 服务")]),_._v(" "),t("ul",[t("li",[_._v("TCP/IP应用层协议\n"),t("ul",[t("li",[_._v("SMTP发送邮件")]),_._v(" "),t("li",[_._v("FTP传输文件（可靠不安全）\n"),t("ul",[t("li",[_._v("TFTP（不可靠不安全）")]),_._v(" "),t("li",[_._v("SFTP（可靠安全）")])])]),_._v(" "),t("li",[_._v("HTTP传输网页文件")]),_._v(" "),t("li",[_._v("以上都对可靠性要求较高，因此都用传输层有连接的TCP服务。")])])]),_._v(" "),t("li",[_._v("无连接的UDP服务效率更高，开销小\n"),t("ul",[t("li",[_._v("DNS在传输层采用无连接UDP服务")])])])]),_._v(" "),t("h2",{attrs:{id:"_14-数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-数据库"}},[_._v("#")]),_._v(" 14.数据库")]),_._v(" "),t("h3",{attrs:{id:"三级模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三级模式"}},[_._v("#")]),_._v(" 三级模式")]),_._v(" "),t("ul",[t("li",[_._v("概念模式\n"),t("ul",[t("li",[_._v("全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式")])])]),_._v(" "),t("li",[_._v("外模式\n"),t("ul",[t("li",[_._v("逻辑结构")])])]),_._v(" "),t("li",[_._v("内模式\n"),t("ul",[t("li",[_._v("索引、存储路径")])])])]),_._v(" "),t("h3",{attrs:{id:"独立性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#独立性"}},[_._v("#")]),_._v(" 独立性")]),_._v(" "),t("ul",[t("li",[_._v("物理独立性：用户的应用程序与存储在磁盘上的数据库的数据是相互独立的")])]),_._v(" "),t("h3",{attrs:{id:"视图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视图"}},[_._v("#")]),_._v(" 视图")]),_._v(" "),t("ul",[t("li",[_._v("基本表：概念视图")]),_._v(" "),t("li",[_._v("存储文件：内部视图")]),_._v(" "),t("li",[_._v("视图：用户视图")])]),_._v(" "),t("h3",{attrs:{id:"数据库设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[_._v("#")]),_._v(" 数据库设计")]),_._v(" "),t("ul",[t("li",[_._v("概念设计：用户角度、E-R图")]),_._v(" "),t("li",[_._v("逻辑设计：E-R图转换关系模式")]),_._v(" "),t("li",[_._v("物理设计：物理存储方法、索引等")])]),_._v(" "),t("h3",{attrs:{id:"范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范式"}},[_._v("#")]),_._v(" 范式")]),_._v(" "),t("blockquote",[t("p",[_._v("1NF、2NF 和 3NF 是关系数据库设计中的三个重要范式，用于规范化数据库表，以减少冗余数据，提高数据的一致性和完整性。")])]),_._v(" "),t("h4",{attrs:{id:"_1nf要点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1nf要点"}},[_._v("#")]),_._v(" 1NF要点")]),_._v(" "),t("blockquote",[t("p",[_._v("第一范式要求数据库表中的每个列都包含不可再分的原子数据，也就是每个单元格中只包含一个值。不应该有多值属性或重复组。")])]),_._v(" "),t("ul",[t("li",[_._v("每个表中的每一列都必须包含不可再分的原子数据")]),_._v(" "),t("li",[_._v("表中的每一行必须具有唯一的标识符，通常是主键")]),_._v(" "),t("li",[_._v("1NF确保了表的结构简单和数据的一致性，是数据库设计的第一步")])]),_._v(" "),t("h4",{attrs:{id:"_2nf要点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2nf要点"}},[_._v("#")]),_._v(" 2NF要点")]),_._v(" "),t("blockquote",[t("p",[_._v("第二范式要求在满足 1NF 的基础上，每列数据都必须完全依赖于表的候选键（Candidate Key）。\n这意味着，如果表的候选键包含多列，"),t("strong",[_._v("那么每一列数据都必须与这些列的组合相关，而不是仅与某一列相关。")])])]),_._v(" "),t("ul",[t("li",[_._v("数据表必须满足1NF")]),_._v(" "),t("li",[_._v("所有非主键列数据必须完全依赖于整个候选键，而不是部分依赖")]),_._v(" "),t("li",[_._v("2NF的目标是消除部分依赖，以避免数据冗余和维护异常")])]),_._v(" "),t("h4",{attrs:{id:"_3nf要点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3nf要点"}},[_._v("#")]),_._v(" 3NF要点")]),_._v(" "),t("blockquote",[t("p",[_._v("第三范式要求在满足 2NF 的基础上，消除非主键列之间的传递依赖。这意味着非主键列不能依赖于其他非主键列。")])]),_._v(" "),t("ul",[t("li",[_._v("数据表必须满足 2NF。")]),_._v(" "),t("li",[_._v("每一非主键列都不能传递依赖于其他非主键列。")]),_._v(" "),t("li",[_._v("3NF 有助于进一步减少数据冗余，确保数据的完整性，提高数据表的清晰性。")])]),_._v(" "),t("h2",{attrs:{id:"_15-各种简称"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-各种简称"}},[_._v("#")]),_._v(" 15.各种简称")]),_._v(" "),t("ul",[t("li",[_._v("RTF：多信息文本格式")]),_._v(" "),t("li",[_._v("WAV：声音文件格式")]),_._v(" "),t("li",[_._v("MPG：视频文件格式")]),_._v(" "),t("li",[_._v("JPG：图片文件格式")])]),_._v(" "),t("h2",{attrs:{id:"_16-计算机组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-计算机组成"}},[_._v("#")]),_._v(" 16.计算机组成")]),_._v(" "),t("h3",{attrs:{id:"硬件基本组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#硬件基本组成"}},[_._v("#")]),_._v(" 硬件基本组成")]),_._v(" "),t("ol",[t("li",[_._v("Cache与主存之间的地址映射由："),t("strong",[_._v("硬件自动完成")])]),_._v(" "),t("li",[_._v("CPU包括：运算器和控制器，其中"),t("strong",[_._v("程序计数器PC在控制器中")])]),_._v(" "),t("li",[_._v("CPU中的算术逻辑单元部件是："),t("strong",[_._v("加法器")])]),_._v(" "),t("li",[_._v("计算机操作的最小单元时间是："),t("strong",[_._v("时钟周期")])])]),_._v(" "),t("h3",{attrs:{id:"osi模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#osi模型"}},[_._v("#")]),_._v(" OSI模型")]),_._v(" "),t("ul",[t("li",[_._v("应用层\n"),t("ul",[t("li",[_._v("这是OSI模式的最高层，直接为用户提供服务，完成用户希望在网络上完成的各种工作。它负责协调各个应用程序间的工作，实现各种服务，如 FTP、HTTP、SMTP、Telnet 等协议")])])]),_._v(" "),t("li",[_._v("表示层\n"),t("ul",[t("li",[_._v("这一层处理用户信息的表示问题，如编码、数据格式转换和加密解密等。他协商和建立数据交换的格式，处理字符集和数字的转换，以及数据的压缩与恢复，以提高传输效率和安全性")])])]),_._v(" "),t("li",[_._v("会话层\n"),t("ul",[t("li",[_._v("负责建立、维持和终止会话，并对数据交换进行管理。它允许用户在两个实体设备之间建立连接，并进行流量控制和错误控制")])])]),_._v(" "),t("li",[_._v("传输层\n"),t("ul",[t("li",[_._v("选择差错恢复协议或无差错恢复协议，对收到的顺序不对的数据包进行重新排序。这层包括TCP、UDP等协议，提供端到端服务")]),_._v(" "),t("li",[_._v("四层交换机、四层的路由器")]),_._v(" "),t("li",[_._v("协议：TCP、UDP")])])]),_._v(" "),t("li",[_._v("网络层\n"),t("ul",[t("li",[_._v("定义端到端的包传输，逻辑地址的标识，以及路由实现的方式和学习的方式")]),_._v(" "),t("li",[_._v("三层交换机、路由器")]),_._v(" "),t("li",[_._v("协议：IP、ICMP、IGMP、IPX、ARP等")])])]),_._v(" "),t("li",[_._v("数据链路层\n"),t("ul",[t("li",[t("strong",[_._v("负责将比特流组合成帧，以及帧的发送与接收")]),_._v("。它处理将数据从一个节点传递到另一个节点的问题，包括差错控制和流量控制")]),_._v(" "),t("li",[_._v("网桥、局域网交换机、虚拟局域网(VLAN)、网卡")]),_._v(" "),t("li",[_._v("协议：PPP")])])]),_._v(" "),t("li",[_._v("物理层\n"),t("ul",[t("li",[_._v("略...")]),_._v(" "),t("li",[_._v("电压、电缆规范、中继器、集线器、双绞线")])])])]),_._v(" "),t("h3",{attrs:{id:"按功能划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按功能划分"}},[_._v("#")]),_._v(" 按功能划分")]),_._v(" "),t("ul",[t("li",[_._v("硬联逻辑级\n"),t("ul",[t("li",[_._v("由计算机的内核、门、触发器等逻辑电路组成")])])]),_._v(" "),t("li",[_._v("微程序级\n"),t("ul",[t("li",[_._v("机器语言是微指令级，程序员用微指令编写的微程序一般直接由硬件执行")])])]),_._v(" "),t("li",[_._v("传统机器级\n*")]),_._v(" "),t("li",[_._v("操作系统级")]),_._v(" "),t("li",[_._v("汇编语言级")]),_._v(" "),t("li",[_._v("高级语言级")]),_._v(" "),t("li",[_._v("应用语言级")])]),_._v(" "),t("h2",{attrs:{id:"_17-软件开发模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-软件开发模型"}},[_._v("#")]),_._v(" 17.软件开发模型")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240823110332.png",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"_18-敏捷开发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-敏捷开发"}},[_._v("#")]),_._v(" 18.敏捷开发")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F296a71ecd7574cfca1faef41f5f4049a.png",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"_19-软件成熟度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-软件成熟度"}},[_._v("#")]),_._v(" 19.软件成熟度")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E8%BD%AF%E4%BB%B6%E6%88%90%E7%86%9F%E5%BA%A6.png",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"_20-函数依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-函数依赖"}},[_._v("#")]),_._v(" 20.函数依赖")]),_._v(" "),t("p",[t("code",[_._v("Y ⊆ X")]),_._v("：Y是X的子集")]),_._v(" "),t("p",[t("code",[_._v("X→Y")]),_._v("：这种函数依赖称为平凡函数依赖。简单来说，只要Y是X的子集，Y就依赖于X。")]),_._v(" "),t("blockquote",[t("p",[_._v("函数依赖的公理系统（即 Armstrong 公理系统）为：设关系模式 R(U, F)，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：")])]),_._v(" "),t("ul",[t("li",[_._v("A1自反律：若 Y ⊆ X ⊆ U，则 X -> Y 为 F 所蕴涵。")]),_._v(" "),t("li",[_._v("A2增广律：若 X -> Y 为 F 所蕴涵，且 Z ⊆ U，则 XZ -> YZ 为 F 所蕴涵")]),_._v(" "),t("li",[_._v("A3传递律：若 X -> Y，Y -> Z 为 F 所蕴涵，则 X -> Z 为 F 所蕴涵")])]),_._v(" "),t("p",[_._v("根据上述三条推理规则又可推出下述三条推理规则：")]),_._v(" "),t("ul",[t("li",[_._v("A4合并规则：若 X -> Y，X -> Z， 则 X -> YZ 为 F 所蕴涵")]),_._v(" "),t("li",[_._v("A5伪传递率：若 X -> Y，WY -> Z，则 XW -> Z 为 F 所蕴涵")]),_._v(" "),t("li",[_._v("A6分解规则：若 X -> Y，Z ⊆ Y，则 X -> Z 为 F 所蕴涵")])]),_._v(" "),t("h2",{attrs:{id:"_21-关系运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-关系运算"}},[_._v("#")]),_._v(" 21.关系运算")]),_._v(" "),t("blockquote",[t("p",[_._v("π：投影")]),_._v(" "),t("p",[_._v("R ✖ S ：笛卡尔积")]),_._v(" "),t("p",[_._v("R ⋈ S ：自然连接")]),_._v(" "),t("p",[_._v("q = R ➗ S, 则q中拥有的的字段等于R中的所有字段去掉S中所有的字段之后剩下的字段。")])]),_._v(" "),t("p",[_._v("表S1")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Sno")]),_._v(" "),t("th",[_._v("Sname")]),_._v(" "),t("th",[_._v("Sdept")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("Mary")]),_._v(" "),t("td",[_._v("IS")])]),_._v(" "),t("tr",[t("td",[_._v("No0002")]),_._v(" "),t("td",[_._v("Candy")]),_._v(" "),t("td",[_._v("IS")])]),_._v(" "),t("tr",[t("td",[_._v("No0003")]),_._v(" "),t("td",[_._v("Jam")]),_._v(" "),t("td",[_._v("IS")])])])]),_._v(" "),t("p",[_._v("表S2")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Sno")]),_._v(" "),t("th",[_._v("Age")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("18")])]),_._v(" "),t("tr",[t("td",[_._v("No0008")]),_._v(" "),t("td",[_._v("19")])]),_._v(" "),t("tr",[t("td",[_._v("No0021")]),_._v(" "),t("td",[_._v("20")])])])]),_._v(" "),t("p",[_._v("笛卡尔积")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Sno")]),_._v(" "),t("th",[_._v("Sname")]),_._v(" "),t("th",[_._v("Sdept")]),_._v(" "),t("th",[_._v("Sno")]),_._v(" "),t("th",[_._v("Age")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("Mary")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("18")])]),_._v(" "),t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("Mary")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0008")]),_._v(" "),t("td",[_._v("19")])]),_._v(" "),t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("Mary")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0021")]),_._v(" "),t("td",[_._v("20")])]),_._v(" "),t("tr",[t("td",[_._v("No0002")]),_._v(" "),t("td",[_._v("Candy")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("18")])]),_._v(" "),t("tr",[t("td",[_._v("No0002")]),_._v(" "),t("td",[_._v("Candy")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0008")]),_._v(" "),t("td",[_._v("19")])]),_._v(" "),t("tr",[t("td",[_._v("No0002")]),_._v(" "),t("td",[_._v("Candy")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0021")]),_._v(" "),t("td",[_._v("20")])]),_._v(" "),t("tr",[t("td",[_._v("No0003")]),_._v(" "),t("td",[_._v("Jam")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("18")])]),_._v(" "),t("tr",[t("td",[_._v("No0003")]),_._v(" "),t("td",[_._v("Jam")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0008")]),_._v(" "),t("td",[_._v("19")])]),_._v(" "),t("tr",[t("td",[_._v("No0003")]),_._v(" "),t("td",[_._v("Jam")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("No0021")]),_._v(" "),t("td",[_._v("20")])])])]),_._v(" "),t("p",[_._v("自然连接")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Sno")]),_._v(" "),t("th",[_._v("Sname")]),_._v(" "),t("th",[_._v("Sdept")]),_._v(" "),t("th",[_._v("Age")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("No0001")]),_._v(" "),t("td",[_._v("Mary")]),_._v(" "),t("td",[_._v("IS")]),_._v(" "),t("td",[_._v("18")])])])]),_._v(" "),t("p",[_._v("S1 ⋈ S2 等价于 π"),t("sub",[_._v("1,2,3,5")]),_._v("(σ"),t("sub",[_._v("1=4")]),_._v("(S1✖S2))")]),_._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("  π\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" R"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("S  "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v("  R✖S\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("WHERE")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" σ\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("AND")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("^")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("OR")]),_._v(" V\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br")])]),t("h2",{attrs:{id:"_22-面向对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-面向对象"}},[_._v("#")]),_._v(" 22.面向对象")]),_._v(" "),t("h3",{attrs:{id:"面向对象分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象分析"}},[_._v("#")]),_._v(" 面向对象分析")]),_._v(" "),t("blockquote",[t("p",[_._v("OOA基于用例模型，通过对象建模记录确定的对象、对象封装的数据和行为，以及对象之间的关系。")])]),_._v(" "),t("p",[_._v("OOA包括3个活动，分别是：")]),_._v(" "),t("ul",[t("li",[_._v("建模系统功能")]),_._v(" "),t("li",[_._v("发现并确定业务对象")]),_._v(" "),t("li",[_._v("组织对象并确定对象间的关系")])]),_._v(" "),t("p",[_._v("活动顺序：")]),_._v(" "),t("ul",[t("li",[_._v("认定对象")]),_._v(" "),t("li",[_._v("组织对象")]),_._v(" "),t("li",[_._v("描述对象间的相互作用")]),_._v(" "),t("li",[_._v("确定对象的操作")]),_._v(" "),t("li",[_._v("定义对象的内部信息")])]),_._v(" "),t("p",[_._v("面向对象的分析方法主要是建立三类模型，分别是：")]),_._v(" "),t("ul",[t("li",[_._v("对象模型")]),_._v(" "),t("li",[_._v("动态模型")]),_._v(" "),t("li",[_._v("功能模型")])]),_._v(" "),t("p",[_._v("在OOA方法中，产生用例模型一般需要经历四个阶段：")]),_._v(" "),t("ul",[t("li",[_._v("确定参与者")]),_._v(" "),t("li",[_._v("确定需求用例")]),_._v(" "),t("li",[_._v("构造用例模型")]),_._v(" "),t("li",[_._v("记录需求用例描述")])]),_._v(" "),t("h3",{attrs:{id:"面向对象设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计"}},[_._v("#")]),_._v(" 面向对象设计")]),_._v(" "),t("ul",[t("li",[_._v("共同重用原则：一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。")]),_._v(" "),t("li",[_._v("开放封闭原则：软件实体（类、模块、函数等）应该是可以扩展的，即开放的。但是不可修改的，即封闭的。")]),_._v(" "),t("li",[_._v("依赖倒置原则：不应该强迫客户依赖于他们不用的方法，接口属于客户，不属于它所在的类层次结构。即依赖于抽象，不依赖于具体，同时，高层模块不应该依赖于低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。")]),_._v(" "),t("li",[_._v("共同封闭原则：包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。")]),_._v(" "),t("li",[_._v("里氏代换原则：任何基类对象可以出现的地方，子类对象也一定可以出现。")]),_._v(" "),t("li",[_._v("迪米特原则：一个对象应当对其他对象有尽可能少的了解。")]),_._v(" "),t("li",[_._v("单一责任原则：就一个类而言，应该仅有一个引起它变化的原因。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。")])]),_._v(" "),t("blockquote",[t("p",[_._v("类可以分为三种类型：实体类、边界类、控制类")])]),_._v(" "),t("p",[_._v("主要活动：")]),_._v(" "),t("ul",[t("li",[_._v("识别类及对象")]),_._v(" "),t("li",[_._v("定义属性")]),_._v(" "),t("li",[_._v("定义服务")]),_._v(" "),t("li",[_._v("识别关系")]),_._v(" "),t("li",[_._v("识别包")])]),_._v(" "),t("blockquote",[t("p",[_._v("面向对象设计支持：多重继承、单重继承和层次继承，但不支持分布式继承。")])]),_._v(" "),t("h2",{attrs:{id:"_23-设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-设计模式"}},[_._v("#")]),_._v(" 23.设计模式")]),_._v(" "),t("ul",[t("li",[_._v("生成器模式(Builder)/创建型模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。")]),_._v(" "),t("li",[_._v("命令模式：将一个请求封装成一个对象，抽象出待执行的动作以参数化某对象。")])]),_._v(" "),t("p",[_._v("类行为模式：")]),_._v(" "),t("ul",[t("li",[_._v("创建型模式中的工厂方法、结构性模式中的适配器模式、行为型模式中的解释器模式与模板方法模式。")]),_._v(" "),t("li",[_._v("抽象工厂：")])]),_._v(" "),t("h2",{attrs:{id:"_24-项目管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-项目管理"}},[_._v("#")]),_._v(" 24.项目管理")]),_._v(" "),t("h3",{attrs:{id:"规模估算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#规模估算"}},[_._v("#")]),_._v(" 规模估算")]),_._v(" "),t("ul",[t("li",[_._v("体系结构模型：代码行数")]),_._v(" "),t("li")]),_._v(" "),t("h3",{attrs:{id:"项目管理工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目管理工具"}},[_._v("#")]),_._v(" 项目管理工具")]),_._v(" "),t("ul",[t("li",[_._v("PERT：图形化的网络模型，描述一个项目中的任务与任务之间的关系")]),_._v(" "),t("li",[_._v("Gantt：简单的水平条形图，它以日历为基准描述项目任务")])]),_._v(" "),t("h3",{attrs:{id:"估算模型cocomo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#估算模型cocomo"}},[_._v("#")]),_._v(" 估算模型COCOMO")]),_._v(" "),t("blockquote",[t("p",[_._v("用3个不同层次的模型反映不同程度的复杂性")])]),_._v(" "),t("ul",[t("li",[_._v("基本模型：静态单变量模型，用一个已估算出来的源代码行数为自变量的函数来计算软件开发工作量")]),_._v(" "),t("li",[_._v("中级模型：在 基本模型 的基础上，再用涉及 产品、硬件、人员、项目等方面属性的影响因素来调整工作量的估算")]),_._v(" "),t("li",[_._v("详细模型：在 中级模型 的基础上，再 考虑对软件工程过程中分析、设计等各步骤的影响")])]),_._v(" "),t("h2",{attrs:{id:"_25-软件度量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-软件度量"}},[_._v("#")]),_._v(" 25.软件度量")]),_._v(" "),t("h3",{attrs:{id:"mccabe度量法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mccabe度量法"}},[_._v("#")]),_._v(" McCabe度量法")]),_._v(" "),t("blockquote",[t("p",[_._v("封闭空间的个数 + 1 为 复杂性度量值")])]),_._v(" "),t("h2",{attrs:{id:"_26-结构化分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-结构化分析"}},[_._v("#")]),_._v(" 26.结构化分析")]),_._v(" "),t("ul",[t("li",[_._v("数据流图(OFD)：从数据传递和加工的角度，用图形的方式刻画系统内数据的运行情况。\n"),t("ul",[t("li",[_._v("用于功能建模")])])]),_._v(" "),t("li",[_._v("数据字典：对数据流图加以补充说明。")]),_._v(" "),t("li",[_._v("实体联系图(E-R)：用于描述数据流图中数据存储及其之间的关系。\n"),t("ul",[t("li",[_._v("用于数据建模")])])]),_._v(" "),t("li",[_._v("状态转化图\n"),t("ul",[t("li",[_._v("用于行为建模")])])])]),_._v(" "),t("h2",{attrs:{id:"_27-结构化设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-结构化设计"}},[_._v("#")]),_._v(" 27.结构化设计")]),_._v(" "),t("blockquote",[t("p",[_._v("设计模块的原则是高内聚低耦合，内聚越高，模块独立性越强；耦合越低，模块独立性越强。")])]),_._v(" "),t("h3",{attrs:{id:"设计图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计图"}},[_._v("#")]),_._v(" 设计图")]),_._v(" "),t("ul",[t("li",[_._v("系统流程图：系统执行过程的描述工具")]),_._v(" "),t("li",[_._v("IPO图：描述了模块的输入输出关系、处理内容、模块的内部数据和模块的调用关系")]),_._v(" "),t("li",[_._v("HIPO图：层次图和IPO图的结合，描述了系统自顶向下的模块关系")]),_._v(" "),t("li",[_._v("模块结构图：描述了系统的模块结构以及模块间的关系，同时也描述了模块之间的控制关系")])]),_._v(" "),t("h3",{attrs:{id:"聚合类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#聚合类型"}},[_._v("#")]),_._v(" 聚合类型")]),_._v(" "),t("p",[_._v("内聚程度从低到高：")]),_._v(" "),t("ul",[t("li",[_._v("偶然(巧合)内聚：完成一组没有关系或松散关系的任务")]),_._v(" "),t("li",[_._v("逻辑内聚：完成逻辑上相关的一组任务")]),_._v(" "),t("li",[_._v("时间内聚：所包含的任务必须在同一时间间隔内执行")]),_._v(" "),t("li",[_._v("过程内聚：处理元素相关，而且必须按待定的次序执行")]),_._v(" "),t("li",[_._v("通信内聚：所有处理元素集中在一个数据结构的区域上")]),_._v(" "),t("li",[_._v("顺序内聚：处理元素相同，而且必须顺序执行")]),_._v(" "),t("li",[_._v("功能内聚：完成单一功能，各个部分协同工作，缺一不可")])]),_._v(" "),t("h3",{attrs:{id:"耦合类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#耦合类型"}},[_._v("#")]),_._v(" 耦合类型")]),_._v(" "),t("p",[_._v("耦合度从低到高：")]),_._v(" "),t("ul",[t("li",[_._v("无直接耦合：两模块无直接关系，联系完全通过主模块的控制和调用")]),_._v(" "),t("li",[_._v("数据耦合：借助参数表传递简单数据")]),_._v(" "),t("li",[_._v("标记耦合：通过参数传递记录信息(数据结构)")]),_._v(" "),t("li",[_._v("控制耦合：传递的信息中包含用于控制模块内部逻辑的信息")]),_._v(" "),t("li",[_._v("外部耦合：访问同一全局变量(非全局数据结构)，不是通过参数表传递")]),_._v(" "),t("li",[_._v("公共耦合：访问同一个公共数据环境(如全局数据结构、共享通信区、公共内存)")]),_._v(" "),t("li",[_._v("内容耦合：一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部")])]),_._v(" "),t("h2",{attrs:{id:"_28-uml"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-uml"}},[_._v("#")]),_._v(" 28.UML")]),_._v(" "),t("ul",[t("li",[_._v("组合结构图：用于画出结构化类的内部内容")]),_._v(" "),t("li",[_._v("顺序图：由一组对象或参与者以及他们之间可能发送的消息构成。强调消息的时间次序的交互图")]),_._v(" "),t("li",[_._v("通信图：强调收发消息的对象或参与者的结构组织。强调的是对象之间的组织结构（关系）")])]),_._v(" "),t("h3",{attrs:{id:"结构图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构图"}},[_._v("#")]),_._v(" 结构图")]),_._v(" "),t("ul",[t("li",[_._v("类图：说明系统的静态设计视图")]),_._v(" "),t("li",[_._v("构件图：说明系统的静态实现视图")]),_._v(" "),t("li",[_._v("用例图：说明系统的用例视图")]),_._v(" "),t("li",[_._v("部署图：说明系统的静态实施视图")])]),_._v(" "),t("h2",{attrs:{id:"_29-数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29-数据结构"}},[_._v("#")]),_._v(" 29.数据结构")]),_._v(" "),t("h3",{attrs:{id:"线性表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[_._v("#")]),_._v(" 线性表")]),_._v(" "),t("ul",[t("li",[_._v("顺序存储：通过元素在存储空间中的相对位置来表示数据元素之间的逻辑关系")]),_._v(" "),t("li",[_._v("链式存储：通过指针链起来的节点来存储数据元素\n"),t("ul",[t("li",[_._v("单链表(线性链表)：只能向后遍历，不能逆序")]),_._v(" "),t("li",[_._v("循环链表：循环链表往往是往表头节点添加数据")]),_._v(" "),t("li",[_._v("双向链表：两个指针域，其一指向直接后继，另一个指向直接钱去，克服了单链表的单向性的缺点。")])])]),_._v(" "),t("li",[_._v("索引存储：分别存储数据元素和元素间关系的存储方式")]),_._v(" "),t("li",[_._v("哈希存储：以关键字Key为自变量，通过一定的函数关系（散列函数或哈希函数），计算出元素的哈希地址。")])]),_._v(" "),t("h3",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[_._v("#")]),_._v(" 栈")]),_._v(" "),t("blockquote",[t("p",[_._v("栈仅在表尾插入和删除元素")]),_._v(" "),t("p",[_._v("用两个栈可以模拟一个队列的入队和出队操作")])]),_._v(" "),t("ul",[t("li",[_._v("函数调用时：\n"),t("ul",[t("li",[_._v("在栈顶创建并临时保留的一段存储空间即栈帧中，会存放调用函数时的返回地址、形参变量和局部变量。")]),_._v(" "),t("li",[_._v("而局部变量存放在程序的静态存储区，位置是相对固定、独立的")])])])]),_._v(" "),t("h3",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[_._v("#")]),_._v(" 队列")]),_._v(" "),t("blockquote",[t("p",[_._v("队列仅在表头删除元素、在表尾插入元素")])]),_._v(" "),t("ul",[t("li",[_._v("循环队列：入队修改尾指针，出队修改头指针\n"),t("ul",[t("li",[_._v("优点：入队和出队都不需要移动队列中的其他元素")])])])]),_._v(" "),t("h3",{attrs:{id:"二维数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二维数组"}},[_._v("#")]),_._v(" 二维数组")]),_._v(" "),t("ul",[t("li",[_._v("假设每个数组元素的长度为 3 个存储单元，行下标 i 为 0 - 8，列下标 j 为 0 - 9，从首地址 SA 开始存放，求元素 "),t("code",[_._v("A[8][5]")]),_._v("的起始地址")])]),_._v(" "),t("blockquote",[t("p",[_._v("二维数组计算地址（按照行优先顺序）的公式为：")]),_._v(" "),t("p",[t("code",[_._v("LOC (i, j) = LOC (0, 0) + ( i * m + j) * L")])]),_._v(" "),t("p",[_._v("其中 LOC (0, 0) = SA，是数组存放的首地址， L = 3 是每个数组的长度： m = 9 - 0 + 1 = 10是数组的列数，")]),_._v(" "),t("p",[_._v("因此 "),t("code",[_._v("LOC (8, 5) = SA + ( 8 * 10 + 5) * 3 = SA + 255")])])]),_._v(" "),t("h3",{attrs:{id:"矩阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#矩阵"}},[_._v("#")]),_._v(" 矩阵")]),_._v(" "),t("ul",[t("li",[_._v("稀疏矩阵\n"),t("ul",[t("li",[_._v("压缩方法：\n"),t("ul",[t("li",[_._v("三元组顺序表")]),_._v(" "),t("li",[_._v("行逻辑连接的顺序表")]),_._v(" "),t("li",[_._v("十字链表")])])])])]),_._v(" "),t("li",[_._v("邻接矩阵\n"),t("ul",[t("li",[_._v("有向图\n"),t("ul",[t("li",[_._v("n个顶点，e条边的有向图的邻接矩阵中，零的个数为：")]),_._v(" "),t("li",[_._v("邻接大小为 n^2，非零个数为 e，零个数为 n^2 - e")])])])])])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("1")])])]),_._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")])])])]),_._v(" "),t("p",[_._v("邻接矩阵A非对称矩阵，说明图是有向图，各顶点的出度为矩阵行中 1 的个数，即 2,2,1,1。")]),_._v(" "),t("ul",[t("li",[_._v("邻接矩阵\n"),t("ul",[t("li",[_._v("无向图：n个顶点，e条边的无向图的邻接矩阵中，零的个数为：\n"),t("ul",[t("li",[_._v("邻接大小为 n^2，非零个数为 2e，所以零元素的个数是 n^2 - 2e")]),_._v(" "),t("li",[_._v("采用深度优先进行遍历的时候，查找所有邻接点所需要的时间为 O(n^2)")])])])])])]),_._v(" "),t("h3",{attrs:{id:"树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[_._v("#")]),_._v(" 树")]),_._v(" "),t("blockquote",[t("p",[_._v("一个有 n 个结点的树的所有度数之和为： n - 1")])]),_._v(" "),t("ul",[t("li",[_._v("哈夫曼树：最优二叉树\n"),t("ul",[t("li",[_._v("树的带权路径长度 = 树中所有叶节点的权值乘上其到根节点的路径长度")]),_._v(" "),t("li",[_._v("没有“度”为 1 的节点")]),_._v(" "),t("li",[_._v("n 个叶子节点的哈夫曼树，度数为 2 的节点数为 n -1 个，所以哈夫曼树一共有 2n - 1 个节点")])])])]),_._v(" "),t("p",[_._v("哈夫曼树：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png",alt:""}})]),_._v(" "),t("p",[_._v("由权值9，2，5，7的四个叶子节点构造的哈夫曼树，带权路径长度为："),t("code",[_._v("9 * 1 + 2*3 + 5*3 + 7*2 = 44")])]),_._v(" "),t("ul",[t("li",[_._v("平衡二叉树：查找的时间复杂度为：O(log2n)\n"),t("ul",[t("li",[_._v("空树是平衡二叉树")]),_._v(" "),t("li",[_._v("任意一个结点的key，比它的左孩子key大，比它的右孩子key小；")]),_._v(" "),t("li",[_._v("任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png",alt:""}})]),_._v(" "),t("ul",[t("li",[t("p",[_._v("一颗度为4的数T中，5个度为4的节点，7个度为3的节点，3个度为2的节点，9个度为1的节点：")]),_._v(" "),t("ul",[t("li",[_._v("树的节点总数为 n，n = 分支数 + 1，而 分支数 = 各个节点的度之和")]),_._v(" "),t("li",[t("code",[_._v("5*4 + 7*3 + 3*2 + 9*1 + 1 = 叶子数 + 5 + 7 + 3 + 9")])])])]),_._v(" "),t("li",[t("p",[_._v("二叉排序树")]),_._v(" "),t("ul",[t("li",[_._v("若它的左子树不空，则左子树上所有结点的值均小于它根结点的值")]),_._v(" "),t("li",[_._v("若它的右子树不空，则右子树上所有结点的值均大于它根结点的值")]),_._v(" "),t("li",[_._v("左子树结点值   <  根结点值  < 右子树结点值")]),_._v(" "),t("li",[_._v("优点：查找效率高")]),_._v(" "),t("li",[_._v("如何构建：")]),_._v(" "),t("li",[_._v("比如给定一个数组 "),t("strong",[_._v("[62,88,58,47,35,73,51,99,37,93]")]),_._v(" ，首先拿到第一个数字，以这个数字为根结点（标准），进行构建，如果比这个数字要大的就放到右子树，比这个要小的就放到左子树去")])])]),_._v(" "),t("li",[t("p",[_._v("完全二叉树：一棵深度为k且有 2^k - 1个结点的二叉树称为满二叉树。")]),_._v(" "),t("ul",[t("li",[_._v("一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[_._v("#")]),_._v(" 图")]),_._v(" "),t("ul",[t("li",[_._v("一个图的邻接矩阵表示唯一，邻接表表示不唯一。")]),_._v(" "),t("li",[_._v("某图G的邻接表有奇数个表示边的表结点，则图G是"),t("strong",[_._v("有向图")])]),_._v(" "),t("li",[_._v("无向图中一个顶点的度是指图中与该顶点相邻的顶点数")]),_._v(" "),t("li",[_._v("使用队列对图进行广度优先遍历")])]),_._v(" "),t("h3",{attrs:{id:"查找方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找方式"}},[_._v("#")]),_._v(" 查找方式")]),_._v(" "),t("ul",[t("li",[_._v("随机查找：无法用于链表，")]),_._v(" "),t("li",[_._v("散列查找：适用于哈希存储")]),_._v(" "),t("li",[_._v("二分查找：只能用于顺序表")]),_._v(" "),t("li",[_._v("顺序查找：可以用于链表")])]),_._v(" "),t("h3",{attrs:{id:"questions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#questions"}},[_._v("#")]),_._v(" Questions")]),_._v(" "),t("ul",[t("li",[_._v("采用顺序表和单链表存储长度为n的线性序列，时间复杂度为：O(1)、O(n)\n"),t("ul",[t("li",[_._v("顺序表：使用前必须指定长度，一旦分配内存则无法修改，优点：访问数据方便")]),_._v(" "),t("li",[_._v("链表：必须从表头开始一步一步搜索元素，优点：可以动态改变数据长度，分配物理空间。")])])]),_._v(" "),t("li",[_._v("在一个长度为n的带头节点的单链表h上，设有尾指针r，则执行《删除单链表的最后一个元素》操作与链表的表长有关\n"),t("ul",[t("li",[_._v("删除单链表最后一个结点需要重置其前驱结点的指针域为NULL，需要从头开始依次遍历找到该前驱节点，需要 O(n)")])])]),_._v(" "),t("li",[_._v("当3个不同元素依次进栈时，它们可以有不同的出栈顺序。\n"),t("ul",[t("li",[_._v("根据排列组合的原则，理论上应该有6种不同的出栈顺序，即abc, acb, cba, cab, bac, bca。然而，经过仔细分析，我们可以发现其中cab是不可能的。这是因为如果元素c在元素b之前进入栈，那么在出栈时，元素a不可能在元素b之前，这就违反了栈的后进先出（LIFO）原则。因此，实际上只有5种有效的出栈顺序：abc, acb, cba, bac, bca。这5种出栈顺序反映了元素进栈后，按照不同的顺序出栈的可能性‌")])])]),_._v(" "),t("li",[_._v("霍夫曼编码：\n"),t("ul",[t("li",[_._v("如果对包含100,000个字符，且这些字符都属于a到f。那么如果采用固定长度的编码，针对于每个字符需要3位来编码（因为有6个不同的字符，至少需要3位才能表示6种不同的变化）。那么对100000个字符编码，其编码长度为300000。如果采用霍夫曼编码，那么首先我们就要根据字符出现的频率构造出其霍夫曼树。首先选择出现频率最低的4和8，生成子树，其父节点为12，然后放入出现频率队列中，后面的采用同样的道理，以此类推。构造出的霍夫曼树如下图所示：由图可以知道，a的编码为00，b的编码为11，c的编码为0100，d的编码为0101，e的编码为011，f的编码为10。因此总的编码长度为"),t("code",[_._v("（2*18%+2*32%+4*4%+4*8%+3*12%+2*26%）*100000=23600")]),_._v("，因此节省的存储空间大小为30000-23600=6400。因此节省的存储空间为比例为6400/30000=21%。")])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);