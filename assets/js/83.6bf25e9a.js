(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{607:function(_,v,t){"use strict";t.r(v);var a=t(4),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-数据的表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据的表示"}},[_._v("#")]),_._v(" 1. 数据的表示")]),_._v(" "),t("h3",{attrs:{id:"进制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进制"}},[_._v("#")]),_._v(" 进制")]),_._v(" "),t("ol",[t("li",[_._v("16进制计算："),t("code",[_._v("38000H = 3*16^4 + 8*16^3 + 0*16^2 + 0*16^1 + 0*16^0 = 229376")])]),_._v(" "),t("li",[_._v("16进制 -> 8进制：先转2进制，然后按照每3位分隔开，不够3的倍数就在前面补0")]),_._v(" "),t("li",[_._v("0x000F = 0000 0000 0000 1111  （F = 16）")])]),_._v(" "),t("h3",{attrs:{id:"码制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#码制"}},[_._v("#")]),_._v(" 码制")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("原码：原码就是符号位加上真值的绝对值，"),t("strong",[_._v("即用第一位表示符号，其余位表示值")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("反码：")]),_._v(" "),t("ul",[t("li",[_._v("正数的反码与原码相同；")]),_._v(" "),t("li",[_._v("负数的反码是在其原码的基础上，符号位不变，其余各个位取反。")])])]),_._v(" "),t("li",[t("p",[_._v("补码："),t("strong",[_._v("最适合进行数字加减运算")])]),_._v(" "),t("ul",[t("li",[_._v("正数的补码与原码相同；")]),_._v(" "),t("li",[_._v("负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)")])])]),_._v(" "),t("li",[t("p",[_._v("移码：")]),_._v(" "),t("ul",[t("li",[_._v("将数值加上一个偏移量（通常是表示范围的一半）来表示。比如，用8位表示时，+5的移码是"),t("code",[_._v("10000101")]),_._v("，-5的移码是"),t("code",[_._v("01111011")]),_._v("。")]),_._v(" "),t("li",[t("strong",[_._v("最适合表示浮点数阶码")])])])])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}}),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("数值1")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("数值-1")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("1 + (-1)")])])]),_._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("原码")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0000 0001")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1000 0001")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1000 0010")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("反码")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0000 0001")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1111 1110")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1111 1111")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("补码")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0000 0001")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1111 1111")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0000 0000")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("移码")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1000 0001")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0111 1111")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1000 0000")])])])]),_._v(" "),t("h3",{attrs:{id:"浮点数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浮点数"}},[_._v("#")]),_._v(" 浮点数")]),_._v(" "),t("ul",[t("li",[_._v("尾数：小数点后的数字")]),_._v(" "),t("li",[_._v("阶码：浮点数的指数部分，即10的多少次方或2的多少次方。‌")]),_._v(" "),t("li",[_._v("数符：浮点数的符号")]),_._v(" "),t("li",[_._v("阶符：阶码的符号")])]),_._v(" "),t("h3",{attrs:{id:"运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运算"}},[_._v("#")]),_._v(" 运算")]),_._v(" "),t("p",[_._v("1.25 * 10^6")]),_._v(" "),t("p",[_._v("1.255 * 10^10")]),_._v(" "),t("p",[_._v("先对阶再相加：小数向大数看齐")]),_._v(" "),t("p",[_._v("0.000125 * 10^10 + 1.255 * 10^10 = 1.255125 * 10^10")]),_._v(" "),t("h3",{attrs:{id:"逻辑运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑运算"}},[_._v("#")]),_._v(" 逻辑运算")]),_._v(" "),t("ul",[t("li",[_._v("与：全1为1，有0为0")]),_._v(" "),t("li",[_._v("或：全0为0，有1为1")]),_._v(" "),t("li",[_._v("非：1变0，0变1")]),_._v(" "),t("li",[_._v("异或：相异为1，相同为0")]),_._v(" "),t("li",[_._v("同或：相同为1，相异为0")]),_._v(" "),t("li",[_._v("与非：先与后非（全1为0，有0为1）")]),_._v(" "),t("li",[_._v("或非：先或后非（全0为1，有1为0）")])]),_._v(" "),t("h2",{attrs:{id:"_2-校验码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-校验码"}},[_._v("#")]),_._v(" 2. 校验码")]),_._v(" "),t("h3",{attrs:{id:"奇偶校验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#奇偶校验"}},[_._v("#")]),_._v(" 奇偶校验")]),_._v(" "),t("h3",{attrs:{id:"海明码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#海明码"}},[_._v("#")]),_._v(" 海明码")]),_._v(" "),t("p",[_._v("1.海明码：2^k - 1 ≥ n + k")]),_._v(" "),t("p",[_._v("不同的海明码码距（Hamming distance）所能实现的功能如下：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("码距为2")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：只能检测出1位错误，但无法纠正任何错误。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：通常用于简单的错误检测场合，适用于不需要纠正错误的情况。")])])]),_._v(" "),t("li",[t("strong",[_._v("码距为3")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：可以检测出1位错误，并能纠正1位错误。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：这是最常用的海明码配置，用于需要纠正单个比特错误的场合，如内存错误纠正（ECC）等。")])])]),_._v(" "),t("li",[t("strong",[_._v("码距为4")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：可以检测出最多2位错误，纠正1位错误。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：适用于需要检测更复杂错误但仍只纠正单比特错误的场合。")])])]),_._v(" "),t("li",[t("strong",[_._v("码距为5")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：可以检测并纠正2位错误，或检测3位错误而不纠正。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：适用于高可靠性要求的系统，在需要纠正双比特错误或检测多比特错误的场合使用。")])])]),_._v(" "),t("li",[t("strong",[_._v("码距为6")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：可以检测最多5位错误，纠正最多2位错误。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：用于极高可靠性要求的通信系统或数据存储系统中，适合需要在发生少量比特错误时仍能有效纠正的场合。")])])]),_._v(" "),t("li",[t("strong",[_._v("码距为7")]),_._v("：\n"),t("ul",[t("li",[t("strong",[_._v("功能")]),_._v("：可以检测6位错误，纠正3位错误。")]),_._v(" "),t("li",[t("strong",[_._v("应用")]),_._v("：在极端条件下使用，需要最大程度的错误检测和纠正能力。")])])])]),_._v(" "),t("h3",{attrs:{id:"crc校验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#crc校验"}},[_._v("#")]),_._v(" CRC校验")]),_._v(" "),t("p",[_._v("循环冗余校验")]),_._v(" "),t("p",[_._v("可检错，不能纠错")]),_._v(" "),t("p",[_._v("在 k 位 信息码之后拼接 r 位 校验码")]),_._v(" "),t("h2",{attrs:{id:"_3-指令系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-指令系统"}},[_._v("#")]),_._v(" 3. 指令系统")]),_._v(" "),t("h3",{attrs:{id:"指令的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令的组成"}},[_._v("#")]),_._v(" 指令的组成")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("操作码字段")]),_._v(" "),t("th",[_._v("地址码字段")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("OP")]),_._v(" "),t("td",[_._v("A1、A2")])])])]),_._v(" "),t("ul",[t("li",[_._v("立即寻址方式\n"),t("ul",[t("li",[_._v("特点：操作数直接在指令中，速度快，灵活性差")])])]),_._v(" "),t("li",[_._v("直接寻址方式\n"),t("ul",[t("li",[_._v("特点：指令中存放的是操作数的地址")])])]),_._v(" "),t("li",[_._v("间接寻址方式\n"),t("ul",[t("li",[_._v("特点：指令中存放了一个地址，这个地址对应的内容是操作数的地址")])])]),_._v(" "),t("li",[_._v("寄存器寻址方式\n"),t("ul",[t("li",[_._v("特点：寄存器存放操作数")])])]),_._v(" "),t("li",[_._v("寄存器间接寻址方式\n"),t("ul",[t("li",[_._v("寄存器内存放的是操作数的地址")])])])]),_._v(" "),t("h3",{attrs:{id:"cisc和risc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cisc和risc"}},[_._v("#")]),_._v(" CISC和RISC")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("指令系统类型")]),_._v(" "),t("th",[_._v("指令")]),_._v(" "),t("th",[_._v("寻址方式")]),_._v(" "),t("th",[_._v("实现方式")]),_._v(" "),t("th",[_._v("其他")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("CISC（复杂指令系统）")]),_._v(" "),t("td",[_._v("数量多，使用频率差别大，可变长指令格式，指令可对主存单元中的数据直接进行处理")]),_._v(" "),t("td",[_._v("支持多种，5~20种")]),_._v(" "),t("td",[_._v("微程序控制技术、采用流水线")]),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td",[_._v("RISC（精简指令系统）")]),_._v(" "),t("td",[_._v("数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存")]),_._v(" "),t("td",[_._v("支持方式少")]),_._v(" "),t("td",[_._v("增加了通用寄存器，一般在32个以上，有的可达上千个，硬布线逻辑控制为主，采用流水线")]),_._v(" "),t("td",[_._v("优化编译，有效支持高级语言")])])])]),_._v(" "),t("h2",{attrs:{id:"_4-存储系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-存储系统"}},[_._v("#")]),_._v(" 4. 存储系统")]),_._v(" "),t("p",[_._v("CPU对应的存储类型：寄存器")]),_._v(" "),t("p",[_._v("Cache对应的存储类型：缓存")]),_._v(" "),t("p",[_._v("主存对应的存储类型：DRAM")]),_._v(" "),t("p",[_._v("辅存对应的存储类型：硬盘、光盘等")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2Fcpu.png",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"dma"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dma"}},[_._v("#")]),_._v(" DMA")]),_._v(" "),t("ul",[t("li",[_._v("DMA传送\n"),t("ul",[t("li",[_._v("让存储器与外设、或外设与外设之间直接交换数据")]),_._v(" "),t("li",[_._v("不需要经过CPU的累加器中转，减少了这个中间环节")]),_._v(" "),t("li",[_._v("内存地址的修改、传送完毕的结束报告都是由硬件电路实现的，因此大大提高了数据的传输速度")]),_._v(" "),t("li",[_._v("一个DMA传送只需要执行一个总线周期")])])])]),_._v(" "),t("h3",{attrs:{id:"闪存-flash-memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闪存-flash-memory"}},[_._v("#")]),_._v(" 闪存(Flash Memory)")]),_._v(" "),t("ul",[t("li",[_._v("掉电后信息不会丢失，属于非易失性存储器")]),_._v(" "),t("li",[_._v("以块为单位进行删除操作")]),_._v(" "),t("li",[_._v("采用随机访问方式，速度很快")]),_._v(" "),t("li",[_._v("在嵌入式系统中可以用Flash来代替ROM存储器")])]),_._v(" "),t("h3",{attrs:{id:"磁盘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#磁盘"}},[_._v("#")]),_._v(" 磁盘")]),_._v(" "),t("blockquote",[t("p",[_._v("磁盘容量分为格式化容量和非格式化容量")])]),_._v(" "),t("p",[_._v("非格式化："),t("code",[_._v("柱面数 * 每柱面磁道数 * 每磁道扇区数 * 每扇区字节数")])]),_._v(" "),t("p",[_._v("格式化：")]),_._v(" "),t("h3",{attrs:{id:"磁盘调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#磁盘调度"}},[_._v("#")]),_._v(" 磁盘调度")]),_._v(" "),t("ul",[t("li",[_._v("先来先服务（FCFS）")]),_._v(" "),t("li",[_._v("最短寻道时间优先（SSTF）")]),_._v(" "),t("li",[_._v("扫描算法（SCAN）")]),_._v(" "),t("li",[_._v("循环扫描（CSCAN）算法")])]),_._v(" "),t("p",[_._v("​")]),_._v(" "),t("h3",{attrs:{id:"图像"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图像"}},[_._v("#")]),_._v(" 图像")]),_._v(" "),t("ul",[t("li",[_._v("字节数\n"),t("ul",[t("li",[_._v("字节数 = 图像水平分辨率 * 图像垂直分辨率 * 颜色深度 / 8")]),_._v(" "),t("li",[_._v("例如 150DPI 扫描分辨率扫描一幅 3 * 4 英寸的彩色图片，得到原始24位真彩色图像的数据量 ： "),t("code",[_._v("3*150*4*150*24/8")])])])])]),_._v(" "),t("h3",{attrs:{id:"页式存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页式存储"}},[_._v("#")]),_._v(" 页式存储")]),_._v(" "),t("p",[_._v("优点：利用率高，碎片小，分配与管理简单")]),_._v(" "),t("p",[_._v("缺点：增加了系统开销，可能产生抖动现象")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.jpg",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例题"}},[_._v("#")]),_._v(" 例题")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("设机器字长为32位，一个容量为16MB的存储器，CPU按照半字寻址，其可寻址的单元数是：")]),_._v(" "),t("p",[_._v("思路：16MB = 16 * 2^20 * 8bit， 机器字长是32位，半字是16bit")]),_._v(" "),t("p",[_._v("计算：16 * 2^20 * 8bit / 16bit = 2^23")])]),_._v(" "),t("li",[t("p",[_._v("若某存储器存储周期为250ns，每次读出16位，该存储器的数据传输率为：")]),_._v(" "),t("p",[_._v("思路：计算的是存储器的带宽，每个存储周期读出 16bit = 2B，因此数据传输率是 2B / (250 * 10^-9s)")]),_._v(" "),t("p",[_._v("结果：8 * 10^6B / s")])])]),_._v(" "),t("h2",{attrs:{id:"_5-输入输出技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-输入输出技术"}},[_._v("#")]),_._v(" 5.输入输出技术")]),_._v(" "),t("h3",{attrs:{id:"多级中断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多级中断"}},[_._v("#")]),_._v(" 多级中断")]),_._v(" "),t("p",[_._v("用堆栈保存程序现场信息是实现多级中断最有效的方法")]),_._v(" "),t("h3",{attrs:{id:"同步异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步异步"}},[_._v("#")]),_._v(" 同步异步")]),_._v(" "),t("p",[_._v("CPU 与 内存储器、PCI总线、I/O接口 之间交互信息都是同步传输方式")]),_._v(" "),t("p",[_._v("I/O接口与打印设备间交互信息是异步传输")]),_._v(" "),t("h3",{attrs:{id:"中断向量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中断向量"}},[_._v("#")]),_._v(" 中断向量")]),_._v(" "),t("p",[_._v("当系统中有多个中断事件时，可以采用中断向量表的方式处理中断。中断向量表用来保存各个中断源的中断服务程序的入口地址。当外设发出中断请求后，由中断控制器确定其中断号，并根据中断号查询中断向量表中的中断服务程序的入口地址，同时中断控制器把中断请求信号提交给CPU。")]),_._v(" "),t("h3",{attrs:{id:"i-o系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-o系统"}},[_._v("#")]),_._v(" I/O系统")]),_._v(" "),t("p",[_._v("I/O系统的五种工作方式：（从上往下，效率依次变高）")]),_._v(" "),t("ul",[t("li",[_._v("程序控制\n"),t("ul",[t("li",[_._v("无条件查询(传送)：I/O端口总是准备好接受主机的输出数据，或是准备好向主机输入数据")]),_._v(" "),t("li",[_._v("程序查询：程序轮询方式，用户程序直接控制主机与外部设备之间的输入/输出操作")])])]),_._v(" "),t("li",[_._v("程序中断：当I/O设备结束(完成、特殊或异常)时，就会向CPU发出中断请求信号，与程序查询方式相比，大大提高了CPU的利用率（例：鼠标、键盘）")]),_._v(" "),t("li",[_._v("DMA（直接内存存取）：允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行数据交换，整个过程无需CPU的干预（例：移动硬盘）")]),_._v(" "),t("li",[_._v("通道：在一定的硬件基础上利用软件手段实现对I/O的控制和传送，更多地免去了CPU的接入，使主机和外设的并行工作程度更高")]),_._v(" "),t("li",[_._v("I/O处理机：专门负责输入/输出的处理机。可以有独立的存储器、运算部件和指令控制部件。")])]),_._v(" "),t("h3",{attrs:{id:"中断处理过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中断处理过程"}},[_._v("#")]),_._v(" 中断处理过程")]),_._v(" "),t("ul",[t("li",[_._v("CPU无需等待也不必查询I/O状态。")]),_._v(" "),t("li",[_._v("当I/O系统准备好以后，发出中断请求信号通知CPU；")]),_._v(" "),t("li",[_._v("CPU接到中断请求后，保存正在执行程序的现场（保存现场），打断的程序当前位置即为断点（栈结构）")]),_._v(" "),t("li",[_._v("（通过中断向量表）转入I/O中的服务程序的执行，完成I/O系统的数据交换")]),_._v(" "),t("li",[_._v("返回被打断的程序继续执行（恢复现场）")])]),_._v(" "),t("h2",{attrs:{id:"_6-总线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-总线"}},[_._v("#")]),_._v(" 6.总线")]),_._v(" "),t("h3",{attrs:{id:"总线类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总线类型"}},[_._v("#")]),_._v(" 总线类型")]),_._v(" "),t("p",[_._v("按连接部件不同：")]),_._v(" "),t("ul",[t("li",[_._v("片内总线：芯片内部的总线，如CPU内部的总线")]),_._v(" "),t("li",[_._v("系统总线：CPU、主存、I/O设备各大部件之间的信息传输线")]),_._v(" "),t("li",[_._v("通信总线：用于计算机系统之间或其他系统之间的通信")])]),_._v(" "),t("h3",{attrs:{id:"pci-scsi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pci-scsi"}},[_._v("#")]),_._v(" PCI/SCSI")]),_._v(" "),t("ul",[t("li",[_._v("PCI：并行内总线，是PC机常用总线")]),_._v(" "),t("li",[_._v("SCSI：并行外总线，是软硬磁盘、光盘、扫描仪常用总线")])]),_._v(" "),t("h3",{attrs:{id:"总线带宽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总线带宽"}},[_._v("#")]),_._v(" 总线带宽")]),_._v(" "),t("blockquote",[t("p",[_._v("每秒传送信息的字节数，单位 B/s")])]),_._v(" "),t("p",[_._v("一个总线周期传送4个字节信息，占用2个时钟周期，时钟频率是10MHZ，带宽 = 20MB/s")]),_._v(" "),t("h2",{attrs:{id:"_7-二叉树遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-二叉树遍历"}},[_._v("#")]),_._v(" 7.二叉树遍历")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/rk%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("先序遍历（前缀式/波兰式）：1245367（先根节点，然后左树，最后右树）")]),_._v(" "),t("li",[_._v("中序遍历：4251637（先左树，然后根节点，最后右树）")]),_._v(" "),t("li",[_._v("后序遍历（后缀式/逆波兰）：4526731（先左树，然后右树，最后根节点）")])]),_._v(" "),t("h2",{attrs:{id:"_8-高级语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-高级语言"}},[_._v("#")]),_._v(" 8.高级语言")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("中间代码")]),_._v(" "),t("ul",[t("li",[_._v("常用的中间代码表达形式有：\n"),t("ul",[t("li",[_._v("语法树")]),_._v(" "),t("li",[_._v("后缀式")]),_._v(" "),t("li",[_._v("三地址代码")])])])])]),_._v(" "),t("li",[t("p",[_._v("移进--归约分析法")]),_._v(" "),t("ul",[t("li",[_._v("自下而上的语法分析方法")])])]),_._v(" "),t("li",[t("p",[_._v("编译程序五个阶段")]),_._v(" "),t("ul",[t("li",[_._v("词法分析：从左到右一个一个的读入源程序，识别单词或符号，然后进行归类")]),_._v(" "),t("li",[_._v("语法分析：在词法分析的基础上，将单词序列分解成各类语法短语，如 “程序”，“语句”，“表达式” 等，对语句结构合法性进行检查")]),_._v(" "),t("li",[_._v("语义分析：审查源程序是否有语义的错误，当不符合语言规范的时候，程序就会报错")]),_._v(" "),t("li",[_._v("代码优化：这个阶段是对前阶段的中间代码进行变换或改造，目的是使生成的目标代码更加高效，即节省时间和空间")]),_._v(" "),t("li",[_._v("目标代码生成：也就是把优化后的中间代码变换成指令代码或汇编代码")])])])]),_._v(" "),t("h2",{attrs:{id:"_9-cpu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-cpu"}},[_._v("#")]),_._v(" 9.CPU")]),_._v(" "),t("ul",[t("li",[_._v("CPU中的运算单元、控制单元和寄存器组通过内部总线连接起来")]),_._v(" "),t("li",[_._v("单核和多核CPU都支持多任务操作系统")])]),_._v(" "),t("h3",{attrs:{id:"进程调度方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程调度方式"}},[_._v("#")]),_._v(" 进程调度方式")]),_._v(" "),t("ul",[t("li",[_._v("可剥夺方式")]),_._v(" "),t("li",[_._v("不可剥夺方式")])]),_._v(" "),t("h3",{attrs:{id:"cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache"}},[_._v("#")]),_._v(" Cache")]),_._v(" "),t("ul",[t("li",[_._v("高速缓冲存储器是存在于主存与CPU之间的一级存储器，由静态存储芯片（SRAM）组成，容量比较小但速度比主存高得多，接近于CPU的速度")]),_._v(" "),t("li",[_._v("Cache通常保存着一份内存的存储器中部分内容的副本（拷贝），该内容副本是最近曾被CPU使用过的数据和程序代码")])]),_._v(" "),t("h2",{attrs:{id:"_10-流水线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-流水线"}},[_._v("#")]),_._v(" 10.流水线")]),_._v(" "),t("ul",[t("li",[_._v("流水线的执行周期为执行时间最长的一段")]),_._v(" "),t("li",[_._v("n 条指令的执行时间\n"),t("ul",[t("li",[_._v("理论公式：(1△t + 2△t +3△t ...) + (n-1) * 3△t(执行周期，即执行时间最长的一条指令)")]),_._v(" "),t("li",[_._v("实践公式：k * t + (n - 1) * t  (流水线建立分为 k 段，如果是取指、分析、执行的话那么k=3，每一段的时间都是执行周期的时间)")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);