(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{628:function(v,e,o){"use strict";o.r(e);var r=o(4),_=Object(r.a)({},(function(){var v=this,e=v.$createElement,o=v._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("p",[v._v("Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。")]),v._v(" "),o("p",[v._v("什么是RPC？")]),v._v(" "),o("p",[v._v("RPC全称为remote procedure call，即"),o("strong",[v._v("远程过程调用")]),v._v("。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。")]),v._v(" "),o("p",[v._v("需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。")]),v._v(" "),o("p",[v._v("RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。")]),v._v(" "),o("p",[v._v("Dubbo官网地址：http://dubbo.apache.org")]),v._v(" "),o("p",[v._v("Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。")]),v._v(" "),o("h2",{attrs:{id:"zookeeper"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[v._v("#")]),v._v(" Zookeeper")]),v._v(" "),o("blockquote",[o("p",[v._v("服务注册中心zookeeper")])]),v._v(" "),o("p",[v._v("下载地址：http://archive.apache.org/dist/zookeeper/")]),v._v(" "),o("h2",{attrs:{id:"dubbo管理控制台"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dubbo管理控制台"}},[v._v("#")]),v._v(" Dubbo管理控制台")]),v._v(" "),o("p",[v._v("我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。")]),v._v(" "),o("p",[v._v("(1) 将dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下")]),v._v(" "),o("p",[v._v("(2) 启动tomcat，此war文件会自动解压")]),v._v(" "),o("p",[v._v("(3) 修改WEB-INF下的dubbo.properties文件，dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号")]),v._v(" "),o("p",[v._v("(4) 重启tomcat")]),v._v(" "),o("p",[v._v("(5) 访问http://localhost:8080/dubbo-admin-2.6.0/ ，输入用户名(root)和密码(root),切换简体中文")]),v._v(" "),o("h2",{attrs:{id:"dubbo相关配置说明"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dubbo相关配置说明"}},[v._v("#")]),v._v(" Dubbo相关配置说明")]),v._v(" "),o("h3",{attrs:{id:"包扫描"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#包扫描"}},[v._v("#")]),v._v(" 包扫描")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:annotation")]),v._v(" "),o("strong",[v._v("package")]),v._v('="com.saberlind.service" />')])]),v._v(" "),o("p",[v._v("服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。")]),v._v(" "),o("p",[v._v("如果不使用包扫描，也可以通过如下配置的方式来发布服务：(比较繁琐，推荐使用包扫描)")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("bean")]),v._v(" "),o("strong",[v._v("id")]),v._v('="helloService" '),o("strong",[v._v("class")]),v._v('="com.saberlind.service.impl.HelloServiceImpl" />')]),v._v(" "),o("p",[v._v("<"),o("strong",[v._v("dubbo:service")]),v._v(" "),o("strong",[v._v("interface")]),v._v('="com.saberlind.api.HelloService" '),o("strong",[v._v("ref")]),v._v('="helloService" />')])]),v._v(" "),o("p",[v._v("作为服务消费者，可以通过如下配置来引用服务：")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:reference")]),v._v(" "),o("strong",[v._v("id")]),v._v('="helloService" '),o("strong",[v._v("interface")]),v._v('="com.saberlind.api.HelloService" />')])]),v._v(" "),o("h3",{attrs:{id:"协议"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[v._v("#")]),v._v(" 协议")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:protocol")]),v._v(" "),o("strong",[v._v("name")]),v._v('="dubbo" '),o("strong",[v._v("port")]),v._v('="20880"/>')])]),v._v(" "),o("p",[v._v("一般在服务提供者一方配置，可以指定使用的协议名称和端口号。")]),v._v(" "),o("p",[v._v("其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。")]),v._v(" "),o("p",[v._v("推荐使用的是dubbo协议。")]),v._v(" "),o("p",[v._v("dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。")]),v._v(" "),o("p",[v._v("也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:protocol")]),v._v(" "),o("strong",[v._v("name")]),v._v('="dubbo" '),o("strong",[v._v("port")]),v._v('="20880" />')]),v._v(" "),o("p",[v._v("<"),o("strong",[v._v("dubbo:protocol")]),v._v(" "),o("strong",[v._v("name")]),v._v('="rmi" '),o("strong",[v._v("port")]),v._v('="1099" />')])]),v._v(" "),o("p",[v._v("使用dubbo协议暴露服务")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:service")]),v._v(" "),o("strong",[v._v("interface")]),v._v('="com.saberlind.service.HelloService" '),o("strong",[v._v("ref")]),v._v('="helloService" '),o("strong",[v._v("protocol")]),v._v('="dubbo" />')])]),v._v(" "),o("p",[v._v("使用rmi协议暴露服务")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:service")]),v._v(" "),o("strong",[v._v("interface")]),v._v('="com.saberlind.service.DemoService" '),o("strong",[v._v("ref")]),v._v('="demoService" '),o("strong",[v._v("protocol")]),v._v('="rmi" />')])]),v._v(" "),o("h3",{attrs:{id:"启动时检查"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#启动时检查"}},[v._v("#")]),v._v(" 启动时检查")]),v._v(" "),o("blockquote",[o("p",[v._v("<"),o("strong",[v._v("dubbo:consumer")]),v._v(" "),o("strong",[v._v("check")]),v._v('="false"/>')])]),v._v(" "),o("p",[v._v("上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。")]),v._v(" "),o("p",[v._v("建议在开发阶段将check值设置为false，在生产环境下改为true。")]),v._v(" "),o("h2",{attrs:{id:"dubbo事务代理的service问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dubbo事务代理的service问题"}},[v._v("#")]),v._v(" Dubbo事务代理的Service问题")]),v._v(" "),o("p",[v._v("通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。")]),v._v(" "),o("p",[v._v("但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。")]),v._v(" "),o("h3",{attrs:{id:"解决"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[v._v("#")]),v._v(" 解决")]),v._v(" "),o("blockquote",[o("p",[v._v("使用cglib的代理方式")])]),v._v(" "),o("p",[v._v("（1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象，添加如下配置：")]),v._v(" "),o("p",[v._v("<"),o("strong",[v._v("tx:annotation-driven")]),v._v(" "),o("strong",[v._v("transaction-manager")]),v._v('="transactionManager" '),o("strong",[v._v("proxy-target-class")]),v._v('="true"/>')]),v._v(" "),o("p",[v._v("（2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型")]),v._v(" "),o("p",[o("code",[v._v("@Service(interfaceClass = HelloService.class)")])])])}),[],!1,null,null,null);e.default=_.exports}}]);