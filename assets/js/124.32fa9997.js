(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{644:function(r,e,t){"use strict";t.r(e);var v=t(4),_=Object(v.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h2",{attrs:{id:"dockerfile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile"}},[r._v("#")]),r._v(" Dockerfile")]),r._v(" "),t("p",[r._v("Dockerfile是用来构建镜像的构建文件，是由一系列命令和参数构成的脚本")]),r._v(" "),t("p",[r._v("步骤：")]),r._v(" "),t("ul",[t("li",[r._v("编写Dockerfile")]),r._v(" "),t("li",[r._v("docker build构建镜像")])]),r._v(" "),t("h3",{attrs:{id:"案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[r._v("#")]),r._v(" 案例")]),r._v(" "),t("p",[r._v("Dockerfile文件如下：")]),r._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[r._v("FROM nginx\nRUN "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[r._v("echo")]),r._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[r._v('"hello world"')]),r._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),r._v(" /usr/share/nginx/html/index.html\n")])]),r._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[r._v("1")]),t("br"),t("span",{staticClass:"line-number"},[r._v("2")]),t("br")])]),t("p",[r._v("docker build构建镜像")]),r._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[r._v("docker build -t mynginx:saberlind "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[r._v(".")]),r._v("\n")])]),r._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[r._v("1")]),t("br")])]),t("p",[r._v("最后的 "),t("strong",[r._v(".")]),r._v(" 代表本次执行的上下文路径。")]),r._v(" "),t("blockquote",[t("p",[r._v("上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。")]),r._v(" "),t("p",[t("strong",[r._v("解析")]),r._v("：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。")]),r._v(" "),t("p",[r._v("如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。")]),r._v(" "),t("p",[t("strong",[r._v("注意")]),r._v("：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。")])]),r._v(" "),t("p",[r._v("运行：")]),r._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[r._v("docker run -d --name nginx -p "),t("span",{pre:!0,attrs:{class:"token number"}},[r._v("91")]),r._v(":80 mynginx:saberlind\n")])]),r._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[r._v("1")]),t("br")])]),t("h3",{attrs:{id:"dockerfile指令参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile指令参数"}},[r._v("#")]),r._v(" Dockerfile指令参数")]),r._v(" "),t("p",[t("strong",[r._v("注意")]),r._v("：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。")]),r._v(" "),t("table",[t("thead",[t("tr",[t("th",[r._v("指令名称")]),r._v(" "),t("th",[r._v("说明")])])]),r._v(" "),t("tbody",[t("tr",[t("td",[r._v("FROM")]),r._v(" "),t("td",[r._v("定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。")])]),r._v(" "),t("tr",[t("td",[r._v("RUN")]),r._v(" "),t("td",[r._v("用于执行后面跟着的命令行命令。有以下俩种格式："),t("br"),r._v("shell 格式：RUN <命令行命令>,"),t("br"),r._v('exec 格式：RUN ["可执行文件", "参数1", "参数2"]，如: RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline')])]),r._v(" "),t("tr",[t("td",[r._v("COPY")]),r._v(" "),t("td",[r._v("复制指令，从上下文目录中复制文件或者目录到容器里指定路径。如: COPY hom* /mydir/")])]),r._v(" "),t("tr",[t("td",[r._v("ADD")]),r._v(" "),t("td",[r._v("ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下："),t("br"),r._v("ADD 的优点："),t("br"),r._v("在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。"),t("br"),r._v("ADD 的缺点："),t("br"),r._v("在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。"),t("br")])]),r._v(" "),t("tr",[t("td",[r._v("CMD")]),r._v(" "),t("td",[r._v("类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:"),t("br"),r._v("CMD 在docker run 时运行。"),t("br"),r._v("RUN 是在 docker build。"),t("br"),t("strong",[r._v("注意")]),r._v("：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。")])]),r._v(" "),t("tr",[t("td",[r._v("ENTRYPOINT")]),r._v(" "),t("td",[r._v("类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。"),t("br"),r._v("但是, 如果运行 docker run 时使用了 --entrypoint 选项，将覆盖 CMD 指令指定的程序。"),t("br"),t("strong",[r._v("注意")]),r._v("：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。")])]),r._v(" "),t("tr",[t("td",[r._v("ENV")]),r._v(" "),t("td",[r._v("设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。")])]),r._v(" "),t("tr",[t("td",[r._v("ARG")]),r._v(" "),t("td",[r._v("构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。"),t("br"),r._v("构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖。"),t("br"),r._v("格式：ARG <参数名>[=<默认值>]")])]),r._v(" "),t("tr",[t("td",[r._v("VOLUME")]),r._v(" "),t("td",[r._v("定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。"),t("br"),r._v("在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。")])]),r._v(" "),t("tr",[t("td",[r._v("EXPOSE")]),r._v(" "),t("td",[r._v("仅仅只是声明端口。"),t("br"),r._v("作用："),t("br"),r._v("帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。"),t("br"),r._v("在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。")])]),r._v(" "),t("tr",[t("td",[r._v("WORKDIR")]),r._v(" "),t("td",[r._v("指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。")])])])])])}),[],!1,null,null,null);e.default=_.exports}}]);