(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{661:function(t,v,_){"use strict";_.r(v);var n=_(4),p=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),_("p",[t._v("设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：")]),t._v(" "),_("p",[_("strong",[t._v("模式：在某些场景下，针对某类问题的某种通用的解决方案。")])]),t._v(" "),_("p",[t._v("场景：项目所在的环境")]),t._v(" "),_("p",[t._v("问题：约束条件，项目目标等")]),t._v(" "),_("p",[t._v("解决方案：通用、可复用的设计，解决约束达到目标。")]),t._v(" "),_("h2",{attrs:{id:"三大类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三大类"}},[t._v("#")]),t._v(" 三大类")]),t._v(" "),_("p",[_("strong",[t._v("创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。")])]),t._v(" "),_("p",[_("strong",[t._v("结构型模式：把类或对象结合在一起形成一个更大的结构。")])]),t._v(" "),_("p",[_("strong",[t._v("行为型模式：类和对象如何交互，及划分责任和算法。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/2f9c9e3dd3f07.png",alt:"401339-20170928225241215-295252070.png"}})]),t._v(" "),_("h2",{attrs:{id:"关键点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键点"}},[t._v("#")]),t._v(" 关键点")]),t._v(" "),_("p",[_("strong",[t._v("单例模式：某个类只能有一个实例，提供一个全局的访问点")])]),t._v(" "),_("p",[_("strong",[t._v("简单工厂：一个工厂类根据传入的参数决定创建出哪一种产品类的实例")])]),t._v(" "),_("p",[_("strong",[t._v("工厂方法：定义一个创建对象的接口，让子类决定实例化那个类")])]),t._v(" "),_("p",[_("strong",[t._v("抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类")])]),t._v(" "),_("p",[_("strong",[t._v("建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造")])]),t._v(" "),_("p",[_("strong",[t._v("原型模式：通过复制现有的实例来创建新的实例")])]),t._v(" "),_("p",[_("strong",[t._v("适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。")])]),t._v(" "),_("p",[_("strong",[t._v("组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。")])]),t._v(" "),_("p",[_("strong",[t._v("装饰模式：动态的给对象添加新的功能。")])]),t._v(" "),_("p",[_("strong",[t._v("代理模式：为其他对象提供一个代理以便控制这个对象的访问。")])]),t._v(" "),_("p",[_("strong",[t._v("亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。")])]),t._v(" "),_("p",[_("strong",[t._v("外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。")])]),t._v(" "),_("p",[_("strong",[t._v("桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。")])]),t._v(" "),_("p",[_("strong",[t._v("模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。")])]),t._v(" "),_("p",[_("strong",[t._v("解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。")])]),t._v(" "),_("p",[_("strong",[t._v("策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。")])]),t._v(" "),_("p",[_("strong",[t._v("状态模式：允许一个对象在其对象内部状态改变时改变它的行为。")])]),t._v(" "),_("p",[_("strong",[t._v("观察者模式：对象间的一对多的依赖关系。")])]),t._v(" "),_("p",[_("strong",[t._v("备忘录模式：在不破坏封装的前提下，保持对象的内部状态。")])]),t._v(" "),_("p",[_("strong",[t._v("中介者模式：用一个中介对象来封装一系列的对象交互。")])]),t._v(" "),_("p",[_("strong",[t._v("命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。")])]),t._v(" "),_("p",[_("strong",[t._v("访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。")])]),t._v(" "),_("p",[_("strong",[t._v("责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。")])]),t._v(" "),_("p",[_("strong",[t._v("迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。")])]),t._v(" "),_("h2",{attrs:{id:"概述23种模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述23种模式"}},[t._v("#")]),t._v(" 概述23种模式")]),t._v(" "),_("p",[_("strong",[t._v("1.单例模式")])]),t._v(" "),_("p",[t._v("单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。")]),t._v(" "),_("p",[t._v("单例模式具备典型的3个特点：1、只有一个实例。 2、自我实例化。 3、提供全局访问点。")]),t._v(" "),_("p",[t._v("因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。")]),t._v(" "),_("p",[t._v("单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。")]),t._v(" "),_("p",[_("strong",[t._v("2.工厂方法模式")])]),t._v(" "),_("p",[t._v("作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。")]),t._v(" "),_("p",[t._v("工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。其UML结构图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/8457ac3ce6a72.png",alt:"401339-20170929204041684-1520979160.png"}})]),t._v(" "),_("p",[_("strong",[t._v("3.抽象工厂模式")])]),t._v(" "),_("p",[t._v("所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。其UML结构图如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/00d575d1d8cbd.png",alt:"401339-20170929204151184-2094793629.png"}})]),t._v(" "),_("p",[_("strong",[t._v("4.建造者模式")])]),t._v(" "),_("p",[t._v("对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。")]),t._v(" "),_("p",[t._v("建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。其UML结构图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/8a08cc3e96ba5.png",alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("5.原型模式")])]),t._v(" "),_("p",[t._v("在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。")]),t._v(" "),_("p",[t._v("它主要应用与那些创建新对象的成本过大时。它的主要优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。UML结构图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/9cfe765c84a40.png",alt:"401339-20170929205441153-1950745368.png"}})]),t._v(" "),_("p",[_("strong",[t._v("模式结构")]),t._v("\n原型模式包含如下角色：\nPrototype：抽象原型类\nConcretePrototype：具体原型类\nClient：客户类")]),t._v(" "),_("p",[_("strong",[t._v("6.适配器模式")])]),t._v(" "),_("p",[t._v("在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。")]),t._v(" "),_("p",[t._v("作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/d7d43b3c07012.png",alt:"401339-20170929205627606-1781915371.png"}})]),t._v(" "),_("p",[_("strong",[t._v("适配器模式包含如下角色")]),t._v("：\nTarget：目标抽象类\nAdapter：适配器类\nAdaptee：适配者类\nClient：客户类")]),t._v(" "),_("p",[_("strong",[t._v("7.桥接模式")])]),t._v(" "),_("p",[t._v("如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是将这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化。")]),t._v(" "),_("p",[t._v("桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/8764ffa9d4975.png",alt:"401339-20170929205836028-1108970959.png"}})]),t._v(" "),_("p",[_("strong",[t._v("桥接模式包含如下角色：")]),t._v("\nAbstraction：抽象类\nRefinedAbstraction：扩充抽象类\nImplementor：实现类接口\nConcreteImplementor：具体实现类")]),t._v(" "),_("p",[_("strong",[t._v("8.组合模式")])]),t._v(" "),_("p",[t._v("组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。")]),t._v(" "),_("p",[t._v("虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/b2a4edf1b519d.png",alt:"401339-20170929210011122-1282025445.png"}})]),t._v(" "),_("p",[_("strong",[t._v("模式结构")]),t._v("\n组合模式包含如下角色：\nComponent: 抽象构件\nLeaf: 叶子构件\nComposite: 容器构件\nClient: 客户类")]),t._v(" "),_("p",[_("strong",[t._v("9.装饰模式")])]),t._v(" "),_("p",[t._v("我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。")]),t._v(" "),_("p",[t._v("装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://lskyimage-1306894954.cos.ap-nanjing.myqcloud.com/2021/10/28/44fce3325cd99.png",alt:"401339-20170929210140794-1843692006.png"}})]),t._v(" "),_("p",[_("strong",[t._v("模式结构")]),t._v("\n装饰模式包含如下角色：\nComponent: 抽象构件\nConcreteComponent: 具体构件\nDecorator: 抽象装饰类\nConcreteDecorator: 具体装饰类")])])}),[],!1,null,null,null);v.default=p.exports}}]);